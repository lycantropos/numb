from __future__ import annotations

from numbers import Rational as _Rational
from typing import Any as _Any, TYPE_CHECKING, overload as _overload

from typing_extensions import Self as _Self, final as _final

from .enums import TieBreaking as _TieBreaking
from .integer import Int as _Int

if TYPE_CHECKING:

    @_final
    class Fraction:
        numerator: _Int
        denominator: _Int

        def round(self, tie_breaking: _TieBreaking, /) -> _Int: ...

        @_overload
        def __new__(
            cls, value: _Int | _Rational | _Self | float | int, /
        ) -> _Self: ...

        @_overload
        def __new__(
            cls, numerator: _Int | int, denominator: _Int | int, /
        ) -> _Self: ...

        def __new__(
            cls,
            numerator: _Self | _Int | _Rational | float | int = ...,
            denominator: _Int | int = ...,
            /,
        ) -> _Self: ...

        def __abs__(self, /) -> _Self: ...

        def __add__(self, other: _Self | _Int | int, /) -> _Self: ...

        def __bool__(self, /) -> bool: ...

        def __ceil__(self, /) -> _Int: ...

        def __divmod__(
            self, divisor: _Self | _Int | int, /
        ) -> tuple[_Int, _Self]: ...

        @_overload
        def __eq__(self, other: _Self | _Int | int, /) -> bool: ...

        @_overload
        def __eq__(self, other: _Any, /) -> _Any: ...

        def __eq__(self, other: _Any, /) -> _Any: ...

        def __float__(self, /) -> float: ...

        def __floor__(self, /) -> _Int: ...

        def __floordiv__(self, divisor: _Self | _Int | int, /) -> _Int: ...

        def __ge__(self, other: _Self | _Int | int, /) -> bool: ...

        def __gt__(self, other: _Self | _Int | int, /) -> bool: ...

        def __hash__(self, /) -> int: ...

        def __le__(self, other: _Self | _Int | int, /) -> bool: ...

        def __lt__(self, other: _Self | _Int | int, /) -> bool: ...

        def __mod__(self, divisor: _Self | _Int | int, /) -> _Self: ...

        def __mul__(self, other: _Self | _Int | int, /) -> _Self: ...

        def __neg__(self, /) -> _Self: ...

        def __pos__(self, /) -> _Self: ...

        def __pow__(
            self, exponent: _Int | int, divisor: None = ..., /
        ) -> _Self: ...

        def __radd__(self, other: _Int | int, /) -> _Self: ...

        def __rdivmod__(
            self, dividend: _Int | int, /
        ) -> tuple[_Int, _Self]: ...

        def __reduce__(self, /) -> tuple[tuple[_Self], tuple[_Int, _Int]]: ...

        def __repr__(self, /) -> str: ...

        def __rfloordiv__(self, dividend: _Int | int, /) -> _Int: ...

        def __rmod__(self, dividend: _Int | int, /) -> _Self: ...

        def __rmul__(self, other: _Int | int, /) -> _Self: ...

        @_overload
        def __round__(self, digits: None = ..., /) -> _Int: ...

        @_overload
        def __round__(self, digits: int, /) -> _Self: ...

        def __round__(self, digits: int | None = ..., /) -> _Self | _Int: ...

        def __rsub__(self, subtrahend: _Int | int, /) -> _Self: ...

        def __str__(self, /) -> str: ...

        def __sub__(self, minuend: _Self | _Int | int, /) -> _Self: ...

        def __rtruediv__(self, dividend: _Int | int, /) -> _Self: ...

        def __truediv__(self, divisor: _Self | _Int | int, /) -> _Self: ...

        def __trunc__(self, /) -> _Int: ...

else:
    try:
        from . import _crithm
    except ImportError:
        from ._rithm import Fraction
    else:
        Fraction = _final(_crithm.Fraction)
        del _crithm
